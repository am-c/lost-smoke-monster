<html>

<head>
	<meta charset="UTF-8">
	<meta name="authoring-tool" content="Adobe_Animate_CC">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Smoke Monster Interaction | Acates Media</title>
	<script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.2/pixi.min.js"></script>
	<script src="https://unpkg.com/pixi-particles@2.1.9"></script>
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.min.js"></script> -->
	<style>
		html,
		body {
			min-height: 100%;
			height: 100%;
		}

		#smokey {
			position: absolute;
			z-index: 1;
		}

		.island img {
			position: absolute;
			width: 100%;
			max-width: 720px;
			background-repeat: no-repeat;
			z-index: 1111;
			user-drag: none;
			user-select: none;
			-webkit-user-drag: none;
		}
	</style>
	<script>
		(function (cjs, an) {
			var p; // shortcut to reference prototypes
			var lib = {}; var ss = {}; var img = {};
			lib.ssMetadata = [];
			(lib.AnMovieClip = function () {
				this.actionFrames = [];
				this.gotoAndPlay = function (positionOrLabel) {
					cjs.MovieClip.prototype.gotoAndPlay.call(this, positionOrLabel);
				}
				this.play = function () {
					cjs.MovieClip.prototype.play.call(this);
				}
				this.gotoAndStop = function (positionOrLabel) {
					cjs.MovieClip.prototype.gotoAndStop.call(this, positionOrLabel);
				}
				this.stop = function () {
					cjs.MovieClip.prototype.stop.call(this);
				}
			}).prototype = p = new cjs.MovieClip();
			// symbols:
			(lib.island_1 = function () {
				this.initialize(img.island_1);
			}).prototype = p = new cjs.Bitmap();
			p.nominalBounds = new cjs.Rectangle(0, 0, 720, 405);
			(lib.island3 = function () {
				this.initialize(img.island3);
			}).prototype = p = new cjs.Bitmap();
			p.nominalBounds = new cjs.Rectangle(0, 0, 720, 405);
			(lib.island4 = function () {
				this.initialize(img.island4);
			}).prototype = p = new cjs.Bitmap();
			p.nominalBounds = new cjs.Rectangle(0, 0, 720, 405);
			(lib.oceanicplane = function () {
				this.initialize(img.oceanicplane);
			}).prototype = p = new cjs.Bitmap();
			p.nominalBounds = new cjs.Rectangle(0, 0, 516, 370);// helper functions:
			function mc_symbol_clone() {
				var clone = this._cloneProps(new this.constructor(this.mode, this.startPosition, this.loop, this.reversed));
				clone.gotoAndStop(this.currentFrame);
				clone.paused = this.paused;
				clone.framerate = this.framerate;
				return clone;
			}
			function getMCSymbolPrototype(symbol, nominalBounds, frameBounds) {
				var prototype = cjs.extend(symbol, cjs.MovieClip);
				prototype.clone = mc_symbol_clone;
				prototype.nominalBounds = nominalBounds;
				prototype.frameBounds = frameBounds;
				return prototype;
			}
			(lib.Symbol6 = function (mode, startPosition, loop, reversed) {
				if (loop == null) { loop = true; }
				if (reversed == null) { reversed = false; }
				var props = new Object();
				props.mode = mode;
				props.startPosition = startPosition;
				props.labels = {};
				props.loop = loop;
				props.reversed = reversed;
				cjs.MovieClip.apply(this, [props]);
				// Layer_1
				this.instance = new lib.oceanicplane();
				this.instance.setTransform(0, 0, 0.2138, 0.1928);
				this.timeline.addTween(cjs.Tween.get(this.instance).wait(1));
				this._renderFirstFrame();
			}).prototype = getMCSymbolPrototype(lib.Symbol6, new cjs.Rectangle(0, 0, 110.3, 71.4), null);
			(lib.Symbol1 = function (mode, startPosition, loop, reversed) {
				if (loop == null) { loop = true; }
				if (reversed == null) { reversed = false; }
				var props = new Object();
				props.mode = mode;
				props.startPosition = startPosition;
				props.labels = {};
				props.loop = loop;
				props.reversed = reversed;
				cjs.MovieClip.apply(this, [props]);
				// Layer_1_copy_copy
				this.instance = new lib.Symbol6();
				this.instance.setTransform(55.1, 35.6, 1, 1, 0, 0, 0, 55.1, 35.6);
				this.timeline.addTween(cjs.Tween.get(this.instance).wait(1).to({ regX: 55.2, regY: 35.7, x: 55.2, y: 35.55 }, 0).wait(1).to({ y: 35.4 }, 0).wait(1).to({ y: 35.25 }, 0).wait(1).to({ y: 35.1 }, 0).wait(1).to({ y: 34.95 }, 0).wait(1).to({ y: 34.8 }, 0).wait(1).to({ y: 34.65 }, 0).wait(1).to({ y: 34.5 }, 0).wait(1).to({ y: 34.35 }, 0).wait(1).to({ y: 34.2 }, 0).wait(1).to({ y: 34.05 }, 0).wait(1).to({ y: 33.9 }, 0).wait(1).to({ y: 33.75 }, 0).wait(1).to({ y: 33.6 }, 0).wait(1).to({ y: 33.45 }, 0).wait(1).to({ y: 33.3 }, 0).wait(1).to({ y: 33.15 }, 0).wait(1).to({ y: 33 }, 0).wait(1).to({ y: 32.85 }, 0).wait(1).to({ y: 32.7 }, 0).wait(1).to({ y: 32.55 }, 0).wait(1).to({ y: 32.4 }, 0).wait(1).to({ y: 32.2 }, 0).wait(1).to({ y: 32.05 }, 0).wait(1).to({ y: 31.9 }, 0).wait(1).to({ y: 31.75 }, 0).wait(1).to({ y: 31.6 }, 0).wait(1).to({ y: 31.45 }, 0).wait(1).to({ y: 31.3 }, 0).wait(1).to({ y: 31.15 }, 0).wait(1).to({ y: 31 }, 0).wait(1).to({ y: 30.85 }, 0).wait(1).to({ y: 30.7 }, 0).wait(1).to({ y: 30.55 }, 0).wait(1).to({ y: 30.4 }, 0).wait(1).to({ y: 30.25 }, 0).wait(1).to({ y: 30.1 }, 0).wait(1).to({ y: 29.95 }, 0).wait(1).to({ y: 29.8 }, 0).wait(1).to({ y: 29.65 }, 0).wait(1).to({ y: 29.5 }, 0).wait(1).to({ y: 29.35 }, 0).wait(1).to({ y: 29.2 }, 0).wait(1).to({ y: 29.05 }, 0).wait(1).to({ y: 28.9 }, 0).wait(1).to({ y: 28.7 }, 0).to({ _off: true }, 1).wait(48));
				// Layer_1_copy
				this.instance_1 = new lib.Symbol6();
				this.instance_1.setTransform(55.1, 28.6, 1, 1, 0, 0, 0, 55.1, 35.6);
				this.instance_1._off = true;
				this.timeline.addTween(cjs.Tween.get(this.instance_1).wait(47).to({ _off: false }, 0).wait(1).to({ regX: 55.2, regY: 35.7, x: 55.2, y: 28.85 }, 0).wait(1).to({ y: 29 }, 0).wait(1).to({ y: 29.15 }, 0).wait(1).to({ y: 29.3 }, 0).wait(1).to({ y: 29.45 }, 0).wait(1).to({ y: 29.6 }, 0).wait(1).to({ y: 29.75 }, 0).wait(1).to({ y: 29.9 }, 0).wait(1).to({ y: 30.05 }, 0).wait(1).to({ y: 30.2 }, 0).wait(1).to({ y: 30.35 }, 0).wait(1).to({ y: 30.5 }, 0).wait(1).to({ y: 30.65 }, 0).wait(1).to({ y: 30.8 }, 0).wait(1).to({ y: 30.95 }, 0).wait(1).to({ y: 31.1 }, 0).wait(1).to({ y: 31.25 }, 0).wait(1).to({ y: 31.4 }, 0).wait(1).to({ y: 31.55 }, 0).wait(1).to({ y: 31.7 }, 0).wait(1).to({ y: 31.85 }, 0).wait(1).to({ y: 32 }, 0).wait(1).to({ y: 32.15 }, 0).wait(1).to({ y: 32.3 }, 0).wait(1).to({ y: 32.45 }, 0).wait(1).to({ y: 32.6 }, 0).wait(1).to({ y: 32.75 }, 0).wait(1).to({ y: 32.9 }, 0).wait(1).to({ y: 33.05 }, 0).wait(1).to({ y: 33.2 }, 0).wait(1).to({ y: 33.35 }, 0).wait(1).to({ y: 33.5 }, 0).wait(1).to({ y: 33.65 }, 0).wait(1).to({ y: 33.8 }, 0).wait(1).to({ y: 33.95 }, 0).wait(1).to({ y: 34.1 }, 0).wait(1).to({ y: 34.25 }, 0).wait(1).to({ y: 34.4 }, 0).wait(1).to({ y: 34.55 }, 0).wait(1).to({ y: 34.7 }, 0).wait(1).to({ y: 34.85 }, 0).wait(1).to({ y: 35 }, 0).wait(1).to({ y: 35.15 }, 0).wait(1).to({ y: 35.3 }, 0).wait(1).to({ y: 35.45 }, 0).wait(1).to({ y: 35.6 }, 0).wait(1).to({ y: 35.7 }, 0).wait(1));
				this._renderFirstFrame();
			}).prototype = p = new cjs.MovieClip();
			p.nominalBounds = new cjs.Rectangle(0, -7, 110.3, 78.4);
			// stage content:
			(lib.island = function (mode, startPosition, loop, reversed) {
				//if (loop == null) { loop = true; }
				//if (reversed == null) { reversed = false; }
				var props = new Object();
				props.mode = mode;
				props.startPosition = startPosition;
				props.labels = {};
				props.loop = loop;
				props.reversed = reversed;
				cjs.MovieClip.apply(this, [props]);
				this.actionFrames = [0];
				// timeline functions:
				//this.frame_0 = function() {
				// actions

				// smoke monster

				PIXI.settings.RESOLUTION = window.devicePixelRatio || 1;

				const sharpness = 0.1;
				const minDelta = 0.05;

				const app = new PIXI.Application({
					autoResize: true,
					//backgroundColor: 0x1099bb, 
					transparent: true,
					width: 700,
					height: 400,
					view: document.querySelector("#smokey")
				});

				const texture = createTexture(0, 8, app.renderer.resolution);
				const pointer = new PIXI.Point(app.screen.width / 2, app.screen.height / 2);
				const emitterPos = pointer.clone();

				const container = new PIXI.particles.ParticleContainer(5000, {
					scale: true,
					position: true,
					rotation: false,
					uvs: false,
					tint: true
				});

				const emitter = new PIXI.particles.Emitter(container, [texture], {
					autoUpdate: true,
					alpha: {
						start: 0.8,
						end: 0.15
					},
					scale: {
						start: 1,
						end: 0.2,
						minimumScaleMultiplier: 1
					},
					color: {
						start: "#000",
						end: "#000"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 0
					},
					noRotation: true,
					rotationSpeed: {
						min: 0,
						max: 0
					},
					lifetime: {
						min: 0.6,
						max: 0.6
					},
					blendMode: "normal",
					frequency: 0.0008,
					emitterLifetime: -1,
					maxParticles: 5000,
					pos: {
						x: 0,
						y: 0
					},
					addAtBack: false,
					spawnType: "circle",
					"spawnCircle": {
						"x": 0,
						"y": 0,
						"r": 4
					}
				});

				let resized = false;

				emitter.updateOwnerPos(emitterPos.x, emitterPos.y);

				app.stage.addChild(container);
				app.stage.interactive = true;
				app.ticker.add(onTick);
				app.stage.on("pointermove", event => pointer.copy(event.data.global));

				window.addEventListener("resize", () => resized = true);

				function onTick(delta) {

					if (resized) {
						app.renderer.resize(window.innerWidth, window.innerHeight);
						resized = false;
					}

					if (!emitterPos.equals(pointer)) {

						const dt = 1 - Math.pow(1 - sharpness, delta);
						const dx = pointer.x - emitterPos.x;
						const dy = pointer.y - emitterPos.y;

						if (Math.abs(dx) > minDelta) {
							emitterPos.x += dx * dt;
						} else {
							emitterPos.x = pointer.x;
						}

						if (Math.abs(dy) > minDelta) {
							emitterPos.y += dy * dt;
						} else {
							emitterPos.y = pointer.y;
						}

						emitter.updateOwnerPos(emitterPos.x, emitterPos.y);
					}

				}

				function createTexture(r1, r2, resolution) {

					const c = (r2 + 1) * resolution;
					r1 *= resolution;
					r2 *= resolution;

					const canvas = document.createElement("canvas");
					const context = canvas.getContext("2d");
					canvas.width = canvas.height = c * 2;

					const gradient = context.createRadialGradient(c, c, r1, c, c, r2);
					gradient.addColorStop(0, "rgba(29, 29, 29, 1)");
					gradient.addColorStop(1, "rgba(29, 29, 29, 0)");

					context.fillStyle = gradient;
					context.fillRect(0, 0, canvas.width, canvas.height);

					return PIXI.Texture.fromCanvas(canvas);
				}
				// end

				//}
				// actions tween:
				this.timeline.addTween(cjs.Tween.get(this).call(this.frame_0).wait(4));
				// Layer_3
				this.movieClip_1 = new lib.Symbol1();
				this.movieClip_1.name = "movieClip_1";
				this.movieClip_1.setTransform(83.2, 349.15, 0.7461, 0.7758, 0, 0, 0, 55.2, 35.7);
				this.timeline.addTween(cjs.Tween.get(this.movieClip_1).wait(4));
				// island_4
				this.instance = new lib.island4();
				this.timeline.addTween(cjs.Tween.get(this.instance).wait(4));
				// island_3
				this.instance_1 = new lib.island3();
				this.timeline.addTween(cjs.Tween.get(this.instance_1).wait(4));
				// island_2
				this.instance_2 = new lib.island_1();
				this.timeline.addTween(cjs.Tween.get(this.instance_2).wait(4));
				this._renderFirstFrame();
			}).prototype = p = new lib.AnMovieClip();
			p.nominalBounds = new cjs.Rectangle(360, 202.5, 360, 202.5);
			// library properties:
			lib.properties = {
				id: 'E1A40592DA1318469D7D9230CC6E16E6',
				width: 720,
				height: 405,
				fps: 24,
				color: "#FFFFFF",
				opacity: 1.00,
				manifest: [
					{ src: "images/island_1.png", id: "island_1" },
					{ src: "images/island3.png", id: "island3" },
					{ src: "images/island4.png", id: "island4" },
					{ src: "images/oceanicplane.png", id: "oceanicplane" }
				],
				preloads: []
			};
			// bootstrap callback support:
			(lib.Stage = function (canvas) {
				createjs.Stage.call(this, canvas);
			}).prototype = p = new createjs.Stage();
			p.setAutoPlay = function (autoPlay) {
				this.tickEnabled = autoPlay;
			}
			p.play = function () { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
			p.stop = function (ms) { if (ms) this.seek(ms); this.tickEnabled = false; }
			p.seek = function (ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
			p.getDuration = function () { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }
			p.getTimelinePosition = function () { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }
			an.bootcompsLoaded = an.bootcompsLoaded || [];
			if (!an.bootstrapListeners) {
				an.bootstrapListeners = [];
			}
			an.bootstrapCallback = function (fnCallback) {
				an.bootstrapListeners.push(fnCallback);
				if (an.bootcompsLoaded.length > 0) {
					for (var i = 0; i < an.bootcompsLoaded.length; ++i) {
						fnCallback(an.bootcompsLoaded[i]);
					}
				}
			};
			an.compositions = an.compositions || {};
			an.compositions['E1A40592DA1318469D7D9230CC6E16E6'] = {
				getStage: function () { return exportRoot.stage; },
				getLibrary: function () { return lib; },
				getSpriteSheet: function () { return ss; },
				getImages: function () { return img; }
			};
			an.compositionLoaded = function (id) {
				an.bootcompsLoaded.push(id);
				for (var j = 0; j < an.bootstrapListeners.length; j++) {
					an.bootstrapListeners[j](id);
				}
			}
			an.getComposition = function (id) {
				return an.compositions[id];
			}
			an.makeResponsive = function (isResp, respDim, isScale, scaleType, domContainers) {
				var lastW, lastH, lastS = 1;
				window.addEventListener('resize', resizeCanvas);
				resizeCanvas();
				function resizeCanvas() {
					var w = lib.properties.width, h = lib.properties.height;
					var iw = window.innerWidth, ih = window.innerHeight;
					var pRatio = window.devicePixelRatio || 1, xRatio = iw / w, yRatio = ih / h, sRatio = 1;
					if (isResp) {
						if ((respDim == 'width' && lastW == iw) || (respDim == 'height' && lastH == ih)) {
							sRatio = lastS;
						}
						else if (!isScale) {
							if (iw < w || ih < h)
								sRatio = Math.min(xRatio, yRatio);
						}
						else if (scaleType == 1) {
							sRatio = Math.min(xRatio, yRatio);
						}
						else if (scaleType == 2) {
							sRatio = Math.max(xRatio, yRatio);
						}
					}
					domContainers[0].width = w * pRatio * sRatio;
					domContainers[0].height = h * pRatio * sRatio;
					domContainers.forEach(function (container) {
						container.style.width = w * sRatio + 'px';
						container.style.height = h * sRatio + 'px';
					});
					stage.scaleX = pRatio * sRatio;
					stage.scaleY = pRatio * sRatio;
					lastW = iw; lastH = ih; lastS = sRatio;
					stage.tickOnUpdate = false;
					stage.update();
					stage.tickOnUpdate = true;
				}
			}
			an.handleSoundStreamOnTick = function (event) {
				if (!event.paused) {
					var stageChild = stage.getChildAt(0);
					if (!stageChild.paused) {
						stageChild.syncStreamSounds();
					}
				}
			}
		})(createjs = createjs || {}, AdobeAn = AdobeAn || {});
		var createjs, AdobeAn;
	</script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" type="text/javascript"></script>
	<script src="libs/smoke.js" type="text/javascript"></script>
	<script>
		var canvas, stage, exportRoot, anim_container, dom_overlay_container, fnStartAnimation;
		function init() {
			canvas = document.getElementById("canvas");
			anim_container = document.getElementById("animation_container");
			dom_overlay_container = document.getElementById("dom_overlay_container");
			var comp = AdobeAn.getComposition("E1A40592DA1318469D7D9230CC6E16E6");
			var lib = comp.getLibrary();
			var loader = new createjs.LoadQueue(false);
			loader.addEventListener("fileload", function (evt) { handleFileLoad(evt, comp) });
			loader.addEventListener("complete", function (evt) { handleComplete(evt, comp) });
			var lib = comp.getLibrary();
			loader.loadManifest(lib.properties.manifest);
		}
		function handleFileLoad(evt, comp) {
			var images = comp.getImages();
			if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }
		}
		function handleComplete(evt, comp) {
			//This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
			var lib = comp.getLibrary();
			var ss = comp.getSpriteSheet();
			var queue = evt.target;
			var ssMetadata = lib.ssMetadata;
			for (i = 0; i < ssMetadata.length; i++) {
				ss[ssMetadata[i].name] = new createjs.SpriteSheet({ "images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames })
			}
			exportRoot = new lib.island();
			stage = new lib.Stage(canvas);
			//Registers the "tick" event listener.
			fnStartAnimation = function () {
				stage.addChild(exportRoot);
				createjs.Ticker.framerate = lib.properties.fps;
				createjs.Ticker.addEventListener("tick", stage);
			}
			//Code to support hidpi screens and responsive scaling.
			AdobeAn.makeResponsive(true, 'both', false, 1, [canvas, anim_container, dom_overlay_container]);
			AdobeAn.compositionLoaded(lib.properties.id);
			fnStartAnimation();
		}
	</script>
	<!-- write your code here -->
</head>

<body style="margin: 0px;" onload="init();">
	<div id="animation_container">
		<canvas width="720" height="405" id="smokey"></canvas>
		<canvas width="720" height="405" id="canvas"
			style="left: 0px; width: 720px; height: 405px; right: 0px; display: block; position: absolute; background-color: rgba(255, 255, 255, 1);"></canvas>

		<div class="island"><img src="images/island4.png"></div>
		<div id="dom_overlay_container"
			style="left: 0px; top: 0px; width: 720px; height: 405px; overflow: hidden; display: block; position: absolute; pointer-events: none;">
		</div>
	</div>
	<div id="preloadjs-container"
		style="width: 10px; height: 10px; overflow: hidden; visibility: hidden; position: absolute; transform: translate(-10px, -10px);">
	</div>
</body>

</html>